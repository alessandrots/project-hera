 Tutorial GIT

1) git init
The .git directory
	On the left you'll notice a .git directory. It's usually hidden but we're showing it to you for convenience.
	If you click it you'll notice it has all sorts of directories and files inside it. You'll rarely ever need to do anything 
	inside here but it's the guts of Git, where all the magic happens.

2) git status
	Os estágios do git:

	 2.1) staged:
		Files are ready to be committed.
	 2.2)unstaged:
		Files with changes that have not been prepared to be commited.
	 2.3)untracked:
		Files aren't tracked by Git yet. This usually indicates a newly created file.
	 2.4) deleted:
		File has been deleted and is waiting to be removed from Git.

3) add all:
	You can also type git add . 
	The dot represents the current directory, so everything in it, and everything beneath it gets added.

4) git reset:
	You can use git reset <filename> to remove a file or files from the staging area.

5) Committing
	Notice how Git says changes to be committed? The files listed here are in the Staging Area, and they are not in our repository yet. 
	We could add or remove files from the stage before we store them in the repository.

	To store our staged changes we run the commit command with a message describing what we've changed. Let's do that now by typing, for ex.:
	git commit -m "Add cute octocat story"

       OBS.:
	Staging Area:
		A place where we can group files together before we "commit" them to Git.
	Commit
		A "commit" is a snapshot of our repository. This way if we ever need to look back at the changes we've made (or if someone else does), 
		we will see a nice timeline of all changes.

6) Wildcards:
	We need quotes so that Git will receive the wildcard before our shell can interfere with it. Without quotes our shell will only execute the
	wildcard search within the current directory. Git will receive the list of files the shell found instead of the wildcard and it will not 
	be able to add the files inside of the octofamily directory.

7) More useful logs:
	Use git log --summary to see more information for each commit. 
	You can see where new files were added for the first time or where files were deleted. 
	It's a good overview of what's going on in the project.

8) git remote:
	Git doesn't care what you name your remotes, but it's typical to name your main one origin.
	It's also a good idea for your main repository to be on a remote server like GitHub in case your machine is lost at sea during a transatlantic
	boat cruise or crushed by three monkey statues during an earthquake.

9) Pushing Remotely
	The push command tells Git where to put our commits when we're ready, and boy we're ready. So let's push our local changes to our origin 
	repo (on GitHub).

	The name of our remote is origin and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we
	can simply run git push and Git will know what to do. Go ahead and push it!

	git push -u origin master

10)  Pulling Remotely
	Let's pretend some time has passed. We've invited other people to our github project who have pulled your changes, made their own commits, 
	and pushed them.
	We can check for changes on our GitHub repository and pull down any new changes by running:
	git pull origin master

	git stash: (IMPORTANTE)
	Sometimes when you go to pull you may have changes you don't want to commit just yet. One option you have, other than commiting, 
	is to stash the changes.
	Use the command 'git stash' to stash your changes, and 'git stash apply' to re-apply your changes after your pull.

11) Differences
	Uh oh, looks like there has been some additions and changes to the octocat family. Let's take a look at what is different from our last commit 	
	by using the git diff command.

	In this case we want the diff of our most recent commit, which we can refer to using the HEAD pointer.
	git diff HEAD.

	HEAD
	The HEAD is a pointer that holds your position within all your different commits. By default HEAD points to your most recent commit, 
	so it can be used as a quick way to reference that commit without having to look up the SHA.

12) Staged Differences (cont'd)
	Good, now go ahead and run git diff with the --staged option to see the changes you just staged. You should see that octodog.txt was created.
	git diff --staged

13) Resetting the Stage
So now that octodog is part of the family, octocat is all depressed. Since we love octocat more than octodog, we'll turn his frown around by removing octodog.txt.

You can unstage files by using the git reset command. Go ahead and remove octofamily/octodog.txt.

 ex.: git reset octofamily/octodog.txt

14) Undo
	git reset did a great job of unstaging octodog.txt, but you'll notice that he's still there. He's just not staged anymore. It would be great if
 	we could go back to how things were before octodog came around and ruined the party.
	Files can be changed back to how they were at the last commit by using the command: git checkout -- <target>. Go ahead and get rid of all the
	changes since the last commit for octocat.txt

*******************************************
 15) BRANCH (Branching Out)
	When developers are working on a feature or bug they'll often create a copy (aka. branch) of their code they can make separate commits to. 
	Then when they're done they can merge this branch back into their main master branch.
	We want to remove all these pesky octocats, so let's create a branch called clean_up, where we'll do all the work:
		git branch clean_up

 15.1) Switching Branches
	Great! Now if you type git branch you'll see two local branches: 
		a main branch named master and y
		our new branch named clean_up.

	You can switch branches using the git checkout <branch> command. Try it now to switch to the clean_up branch:
		git checkout clean_up

 16) All at Once
	You can use:
		git checkout -b new_branch

	to checkout and create a branch at the same time. This is the same thing as doing:
		git branch new_branch
		git checkout new_branch

 17) Removing All The Things
	Ok, so you're in the clean_up branch. You can finally remove all those pesky octocats by using the git rm command which will not only remove
	the actual files from disk, but will also stage the removal of the files for us.
	You're going to want to use a wildcard again to get all the octocats in one sweep, go ahead and run:
		git rm '*.txt'

	Remove all the things!
	Removing one file is great and all, but what if you want to remove an entire folder? You can use the recursive option on git rm:
		git rm -r folder_of_cats
	This will recursively remove all folders and files from the given directory.

 18) The '-a' option
	If you happen to delete a file without using 'git rm' you'll find that you still have to 'git rm' the deleted files from the working tree. 
	You can save this step by using the '-a' option on 'git commit', which auto removes deleted files with the commit.
		git commit -am "Delete stuff"

 19) Switching Back to master
	Great, you're almost finished with the cat... er the bug fix, you just need to switch back to the master branch so you can copy (or merge) your 	changes from the clean_up branch back into the master branch.

	Go ahead and checkout the master branch:
		git checkout master

 20) Pull Requests
	If you're hosting your repo on GitHub, you can do something called a pull request.
	A pull request allows the boss of the project to look through your changes and make comments before deciding to merge in the change. 
	It's a really great feature that is used all the time for remote workers and open-source projects.
	Check out out the pull request help page for more information.

 21) 1.23 Preparing to Merge
	Alrighty, the moment has come when you have to merge your changes from the clean_up branch into the master branch. 
	Take a deep breath, it's not that scary.

	We're already on the master branch, so we just need to tell Git to merge the clean_up branch into it:
		git merge clean_up

 22) Merge Conflicts
	Merge Conflicts can occur when changes are made to a file at the same time. A lot of people get really scared when a conflict happens, 
	but fear not! They aren't that scary, you just need to decide which code to keep.

	Merge conflicts are beyond the scope of this course, but if you're interested in reading more, take a look the section of the Pro Git book on
	how conflicts are presented.

 23) Keeping Things Clean
	Congratulations! You just accomplished your first successful bugfix and merge. All that's left to do is clean up after yourself. 
	Since you're done with the clean_up branch you don't need it anymore.
	You can use git branch -d <branch name> to delete a branch. Go ahead and delete the clean_up branch now:
		git branch -d clean_up

	Force delete (IMPORTANTE)
		What if you have been working on a feature branch and you decide you really don't want this feature anymore? You might decide to delete 		the branch since you're scrapping the idea. You'll notice that git branch -d bad_feature doesn't work. This is because -d won't let you 		delete something that hasn't been merged.
		You can either add the --force (-f) option or use -D which combines -d -f together into one command.

 24) The Final Push
	Here we are, at the last step. I'm proud that you've made it this far, and it's been great learning Git with you. 
	All that's left for you to do now is to push everything you've been working on to your remote repository, and you're done!
		git push


************************************************************************************************************


>>> DICAS IMPORTANTES:

	1) links importantes:
		https://help.github.com/
		http://git-scm.com/book
		http://git-scm.com/book/en/Customizing-Git-Git-Hooks


	2) http://git-scm.com/book/en/Getting-Started-First-Time-Git-Setup
		git config --global color.branch auto
		git config --global color.diff auto
		git config --global color.interactive auto
		git config --global color.status auto

		$ git config --global user.name "John Doe"
		$ git config --global user.email johndoe@example.com
		$ git config --global core.editor emacs
		$ git config --global merge.tool vimdiff
		$ git config --list

	3) git reset --soft HEAD^ (UNDO last commit, put changes into stages, rollback the last commit)

	4) git commit --amend -m "New Message": Change the last commit.

	5) git reset --hard HEAD^ (UNDO last commit and all changes)

	6) git reset --hard HEAD^^ (UNDO last 2 commit and all changes)

	6.1) Para descartar as mudanÇas
	 ex.: git checkout -- index.html test.hml

	 - GITHUB
	 - BitBucket
	 - Gitosis
	 - Gitorious


	git push -u origin master
	 origin : Remote repository name
	 master : local branch to push

	7) 
	https://github.com/settings/

	para mudar a senha do GITHUB e 
	https://github.com/settings/

	Para gerar a para a senha keygen:
	http://blog.dmatoso.com/2011/09/git-no-windows-github/
	 >>> No item 3

	-> git pull : to pull changes down from the remote (origin)


